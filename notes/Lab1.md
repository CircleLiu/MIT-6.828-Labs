#Lab 1: Booting a PC

## 运行起来

1. 首先先把仓库拉下来

   ```bash
   git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab
   ```

2. 然后编译

   ```bash
   cd lab
   make
   ```

## Part 1: PC Bootstrap

### Getting Started with x86 assembly

这一部分主要是熟悉汇编语言

### Simulating the x86
使用下面命令运行，就不会弹出一个单独的命令行界面，也不会隐藏鼠标，而是直接在本地Terminal中显示
```bash
make qemu-nox
```

### PC物理地址空间

早期基于16位Intel 8088处理器只能操作1MB物理内存，因此物理地址空间起始于0x00000000到0x000FFFFF，其中640KB为 Low memory，这只能被随机存储器(RAM)使用。

从 0x000A0000 到 0x000FFFFF 的384KB留着给特殊使用，例如作为视频显示缓存或者储存在非易失存储器的硬件。从 0x000F0000 到 0x000FFFFF 占据64KB区域的部分是最重要的BIOS。BIOS的功能这里就不细说了。

现在的x86处理器支持超过4GB的物理RAM，所以RAM扩展到了0xFFFFFFFF。当然，BIOS也流出了开始的32位寻址空间为了让32位的设备映射。JOS这里只用开始的256MB，所以假设PC只有32位地址空间。

### BIOS

在一个终端中输入 `make qemu-gdb` ， 另一个终端输入 `make gdb` 。开始调试程序。

```
[f000:fff0] 0xffff0: ljmp $0xf000,$0xe05b
```

是GDB反汇编出的第一条执行指令，这条指令表面了：

- IBM PC 执行的起始物理地址为 0x000ffff0
- PC 的偏移方式为 CS = 0xf000，IP = 0xfff0
- 第一条指令执行的是 jmp指令，跳转到段地址 CS = 0xf000，IP = 0xe05b

QEMU模拟了8088处理器的启动，当启动电源，BIOS最先控制机器，这时还没有其他程序执行，之后处理器进入实模式也就是设置 CS 为 0xf000，IP 为 0xfff0。在启动电源也就是实模式时，地址转译根据这个公式工作：物理地址 = 16 * 段地址 + 偏移量。所以 PC 中 CS 为 0xf000 IP 为 0xfff0 的物理地址为：

```
   16 * 0xf000 + 0xfff0   # 十六进制中乘16很容易
   = 0xf0000 + 0xfff0     # 仅仅添加一个0.
   = 0xffff0
```

关于实模式，参考[CPU的实模式和保护模式(一)](https://zhuanlan.zhihu.com/p/42309472):

> 实模式出现于早期8088CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：
>
> 　　(段基址：段偏移量)
>
> 　 其中第一个字段是段基址，它的值是由**段寄存器**提供的(一般来说，段寄存器有6种，分别为cs，ds，ss，es，fs，gs，这几种段寄存器都有自己的特殊意义，这里不做介绍)。
>
> 　 第二字段是段内偏移量，代表你要访问的这个内存地址距离这个段基址的偏移。它的值就是由通用寄存器来提供的，所以也是16位。那么两个16位的值如何组合成一个20位的地址呢？CPU采用的方式是把段寄存器所提供的段基址先向左移4位。这样就变成了一个20位的值，然后再与段偏移量相加。
>
> 即：
>
> 　　物理地址 = 段基址<<4 + 段内偏移
>
> 　　所以假设段寄存器中的值是0xff00，段偏移量为0x0110。则这个地址对应的真实物理地址是 0xff00<<4 + 0x0110 = 0xff110。
>
> 由上面的介绍可见，实模式的"实"更多地体现在其地址是真实的物理地址。

0xffff0 在 BIOS (0x100000) 的结束地址之前。

当BIOS启动，它设置了一个中断描述符表并初始化多个设备比如VGA显示器。在初始化PCI总线和所有重要的设备之后，它寻找可引导的设备，之后读取 *boot loader* 并转移控制。

